# reactive-di

Хочу рассказать об одной своей js-библиотеке для реактивного программирования (reactive-di), которая идейно чем-то похожа на mobx, cellx, $mol_atom, но основана на развитии идей инверсии контроля и внедрения зависимостей.

Раньше я много лет программировал на php. В общем то карьера моя как php-программиста началось в 2005, а закончилась году в 2011, за это время я успел увидеть, как типизация в языке становится стандартом и как из-за этого от синглтонов  (code igniter, kohana, symfony1, zend1, yii) постепенно переходят к инверсии зависимостей и SOLID (symfony2, zend2, yii2, laravel). Я считаю, что по мере усложнения задач, все языки, рано или поздно проходят похожий путь. Когда мы говорим паттерн или лучшая практика проектирования, то следует учитывать контекст, где она лучшая.

Например, паттерн синглтон был самым популярным в php до symfony2 (а многие скажут, что и до сих пор) из-за своей простоты, т.к. кроме конструкций языка, сторонних библиотек использовать было не нужно. Однако из-за сильной связанности и невозможности подменить без костылей один снглтон на другой (зависимость то прямая), ограничен масштаб приложений (если обойтись без скатывания в говнокод и без шаблонного кода). Т.е. целесообразность использования паттерна зависит не только от решаемой задачи, но и от масштаба приложения, и уровня развития языка (типы, рефлексия).

Наверное многие, кто программировал на зрелых с++ подобных языках, вроде java, c#, php, знают что такое SOLID, ну или по крайней мере буква D в этой аббревиатуре.

D - Dependency injection или внедрение зависимостей, некая универсальный фабрика. Т.е. вы создаете класс, а все его зависимости передаете в конструктор, описывая их в виде интерфейсов. А специальная библиотека (Spring DI в Java, Ninject в C#, Symphony2 DI в php), при запросе данного класса через нее, автоматически распознает эти зависимости, настраивает и перередает в конструктор.

Вынесение знания о том, как создать тот или иной экземпляр класса в отдельный слой приложения - это инверсия контроля. DI - механизм реализации этой инверсии. Этот подход применим не только к классам, но и к функциям, если те порождают другие функции (замыкания).

Суть проблемы в том, что почти любой класс, объект с методами, функция в приложении требует предварительной настройки.
Можно сделать один статический класс или объект с настройками и импортировать его в каждом модуле, где нужны настройки. Но этот путь плох сильным зацеплением кода - многие части кода получают знание о конкретном объекте с данными. Потом нельзя без рефакторинга для одной части кода сменить одни настройки на другие, не затронув остальной код.

Поэтому все хорошие библиотеки экспортируют либо функции-фабрики (redux), либо классы. В точке входа в приложение эти классы инициализируются и связываются. Говоря иначе, основной код приложения, там где находится бизнес-логика, ничего не знает об инициализации своих частей, а знание об этом выносится в отдельный слой.

Это делает части приложения легко настраиваевыми, заменяемыми и интегрируемыми в каркас DI, а также более пригодными для unit-тестирования. Но важно не сколь удобство тестирования, сколь именно вынесение знания о прямых зависимостях из основного кода в отдельный слой и автоматизация создания классов.

Т.е. если до изобретения Di писали так (Примеры кода здесь и далее я буду писать на js+flowtype):

```js
// a.js
export default {
    methodA() {
        return 1
    }
}
```

```js
// b.js
import a from './a'

export default {
   methodB() {
       return 2 + a.methodA()
   }
}

// b.methodB()
```

То после, стали писать так:

```js
// A.js
export interface IA {
   methodA(): number;
}
export default class A {
   methodA() {
      return 1
   }
}
```

```js
// B.js
import type {IA} from './A'
export default class B {
   _a: IA
   constructor(a: IA) {
      this._a = a
   }
   methodB() {
      return 2 + this._a.methodA()
   }
}
```
Что дало возможность убрать прямую зависмость b от a, перевести ее на менее сильную - интерфейс IA.

Есть еще одно понятие, не связанное с DI - это реактивность. Когда есть объект с данными (atom, cell, источник, source, mobx property, observable) и его свойства можно не только читать, но и подписываться на изменения в них. А также есть потребители этих данных и изменений в них (потребитель, consumer, observer, component), например компоненты react. И при изменении данных, происходит какое-то действие - к примеру перерисовка компонента. Кроме этого есть еще промежуточные звенья (computed, derivable, вычисляемая ячейка) - которые стоят на пути от источников к потребителям и преобразуют или комбинируют данные из нескольких источников в нечто более удобоваримое для потребителей.

Есть еще связанные с этим понятия push и pull-архитектура. Пусть есть observable-данные: атом ($mol_atom) или ячейка (cellx) или объект mobx и есть компонент, который использует эти данные. Изначально, при первой прорисовке компонента, данные не актуальны, т.е. их надо загрузить с сервера. Вопрос, где размещать связанную с загрузкой логику?

Push - загрузка происходит в хуке componendDidMount компонента, в большинстве фронтенд приложений так и делают.
Pull - сама модель имеет аналогичный хук pull и любой компонент, который первый запросил эту модель, вызовет этот хук. Т.к. одну и ту же модель могут использовать разные компоненты, то такой перенос логики поближе к модели уменьшает дублирование кода. Один раз написав модель с таким хуком, мы больше не задумываемся, актуальны данные в модели или нет - модель сама себя актуализирует, когда нужно. Аналогично подход работает и для сохранения данных.

Более подробно см. статьи @vintage и @Riim на хабре.

Я же, читая их статьи, ковыряясь в коде их библиотек, а также в коде angular2, react, mobx, и используя опыт работы с  symfony2, ninject, уже 2 года пытаюсь развить идею реактивного внедрения зависимостей. Мои эксперименты - это попытка использовать внедрение завимостей не только для управления инициализацией классов, но и для управления реактивностью внутри приложения. Если решения вроде mobx, cellx, $mol_atom - это реактивные обертки над данными внутри бизнес-логики (собственно кода приложения), то мой подход - это бизнес логика внутри реактивных оберток, состоянием которых управлет контейнер DI и которые в коде приложения никоем образом не видны, по крайней мере тогда, когда дело касается чтения данных.

К чему я стремлюсь, разрабатывая reactive-di:

1. Отсутствие зависимостей от реализаций библиотек в коде, там, где возможно (т.е. React.* в коде уже не годится).
2. Максимально использовать типизацию для автоматической инициализации зависимостей в runtime, т.е. без flowtype или typescript эта штука не имеет смысла, т.к. метаданные к сигнатурам конструкторов и фабрик придется писать вручную.
3. Показать, как можно прекратить войну фреймворков. Сделать компоненты с нулевыми зависимостями похожими на чистые (pure component) компоненты реакта для совместимости с nuclide и аналогичными ide (проверка типов свойств компонета, автокомплит и т.д.) Но иметь возможность взаимозаменять библиотеки вробе react, inferno, morphdom, bel - меняются только адаптеры в точке инициализации, а код остается прежним без пересборки.
4. Отсутствие специфичных для реактивных библиотек, оберток над данными в коде: по возможности оставить только модели, компоненты и сервисы с бизнес-логикой. Обертки есть, но только при общении с сервером Promise, Observable и при записи данных в модели
5. Дать хотя бы частично возможность легко использовать SOLID в js (пока кроме angular2 и inversify никто и близко не приблизился к этому, да и то, некоторые вещи там переусложнены)
6. Дать возможность писать код с минимумом util-мусора, шаблонных конструкций, декораторов, обойтись без слоя конфигурации контейнера DI.
7. Использовать pull-архитектуру
8. Возможность мониторинга не хуже redux

reactive-di - это поиск компромиса по реализации SOLID в реактивных приложениях на js, с учетом существующей js-экосистемы: библиотек, уровня развития языка, инструментов разработки и ide.

## Немного критики

Далее я пытаюсь озвучить то, что на мой взгляд тормозит развитие SOLID на js, почему reactive-di не велосипед. Какие недостатки экосистемы я старался исправить.

Про почти всю экосистему js можно сказать одной фразой: "прибито гвоздями". Вот про c#, java, php нельзя, ибо широко используются DI, SOLID, а про js из-за медленного развития и хреновой системы типов, жалкой рефлексии - можно.

Например, в php типы повились за пару лет до того как я завязал с ним. За это время в нем были созданы или (правильнее сказать переосмысленны java-решения) множество библиотек и фреймворков, сильно использующие и типизацию и аннотации (декораторы), DI и SOLID, интеграцию с ide, где был возможен рефакторинг и много других плюшек, которые дает типизация.

А когда был создан typescript? Вот именно, и только сейчас с очень большим опозданием, чуть ли не насильно продвигается angular2-4. Говорить о целесообразности этого подхода для js не цель этой статьи, но я уверен, что с усложнением задач, не зависимо от предметной области, все придет к SOLID или чему-то похожему. Angular2 это первая и единственная ласточка (или даже франкенштейн), но сравнительно полноценный и привесенные в него идеи - новые в мире frontend. Здесь экосистема js только начинает свой путь в зрелость.

### Или возьмем компоненты

Нет универсальных компонент, а есть война компонентов (react, vue, angular, etc). Эти популярные библиотеки завязываются не на интерфейсы, а на реализации. Поэтому нельзя без костылей, вроде подмены модулей в webpack, сменить реакт даже на inferno. Есть конечно попытки исправить ситуацию, вроде substack/hyperx. Но, в любом случае компоненты - функции не без внешних зависимостей (внутри React.createElement или Inferno.createElement h-функция или что-то еще)

Или взять спецификацию Jsx. Jsx прибит к реакту, даже если не использовать extends React.Component. Jsx преобразуется в дерево вызовов React.createElement. Если пошаманить с babelrc, то можно завязаться на любой другой createElement, но связь статическая, без пересборки такой компонент не адаптировать к другому фреймворку.

Достаточно добавить еще один аргумент в чистый компонент и вот компонент с нулевыми зависимостями от внешних фреймворков:

```js
function MyComponent(props: Props, h: CreateElement) {
   return <div>...</div>
}
```

Про аналогичные es-стандарты, отдельные песня. Да есть сообщество, которое что-то там разрабатывает, но их деятельность больше похожа на философский футбол. Результаты не жизнеспособны, это видно по трендам того же polymer. Нельзя угадать внешний вид апи без опыта экспериментов в реальных крупных проектах, умозрение тут не поможет.

Про стили аналогично, только тут проблема усложняется тем, что есть статические сборщики sass, less и есть динамическая генерация css: jss, typestype, со всеми плюсами и минусами, которые описывать можно в отдельной статье. Но суть одна, для последних нет общепринятой спецификации, точнее есть cssx, но он не является настолько популярным, как jsx, и каждый библиотекописатель городит свой внешний вид js-to-css.

### Про типизацию

Тут все просто. React прибит к flowtype через jsx intrinsic, angular2 прибит к typescript (поддержка типов в шаблонах). Т.е. разработчики "компиляторов" прибивают гвоздями попсовые фреймворки к компиляторам, т.к. нет общепринятых спецификаций этих компонент, а есть конкретные реализации у react, vue, angular2 и кучи других, надо быть в тренде, проще "прибить гвоздями".

Системы типов сильно помогают в js, но и они не полноценны, например, как получить сигнатуру интерфейса в runtime? Для flow/babel еще можно придумывать костыли (babel-плагины), которые сделают из

```js
interface IA {}

class A implements IA {}

di.register((_: IA), A)
```

нечто такое:

```js
interface IA {}

class A implements IA {}

di.register('2oirj9i32jr8u3ruh32', A)
```

Но конструкция ``` (_: IA) ``` костыль, нет в js способа получить интерфейс как значение (как есть в c# или java), т.к. нет стандартов.

### Декораторы

Декоратор только маскирует связанность, но не уменьшает ее, т.к. зачастую декоратор не просто дописывает метаданные к классу (как оно должно быть), это здоровенная функция с кучей логики (react-connext в redux, mobx-react, observable в mobx и т.д.), которая меняет поведение класса или своства.
Вызов декоратора, если убрать сахар с собачкой, чем-то напоминает старый недобрый ``` React.createClass({bla-bla}) ```
В новой спецификации декораторов хотели даже убрать возможность прямого оборачивания класса или свойства, но не решились.
В пхп эти самые декораторы вообще писались как комментарии в коде и без препроцессора, никак не могли повлиять на поведение класса. Я считаю, что задача декоратора - только добавлять метаданные.

В этой статье я эту тему развивать далее не буду, т.к. считаю, что все это кризис взросления экосистемы и носит временный характер. Сосредоточусь на reactive-di.

## Компоненты
